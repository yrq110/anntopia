import{d as T,b as V,a as X,c as J,e as Y,u as M}from"./app.b967f97b.js";class j{constructor(t,e,o){this.config=e,this.dataPoints=t,this.interpolationPoints=[],this.step=o!=null?o:.05}setStep(t){this.step=t}getStep(){return this.step}setConfig(t){this.config=Object.assign(this.config,t)}getConfig(){return this.config}getInterpolation(t=!0){return t&&(this.validate(),this.interpolationPoints=this.interpolate()),this.interpolationPoints}}var m,O;(O=m||(m={}))[O.Natural=0]="Natural",O[O.Clamped=1]="Clamped",O[O.NotAKnot=2]="NotAKnot";const A={boundary:0,derivatives:[0,0]};class Z extends j{constructor(t,e,o){super(t,e?Object.assign(A,e):A,o)}validate(){const t=this.dataPoints,e=t.length/2;for(let s=0;s<e-1;s+=1)if(t[2*s]>t[2*(s+1)])throw new Error("CubicSpline: the trend of x in dataPoints should be one direction");const{boundary:o,derivatives:n}=this.config;if(o===m.Clamped&&n.length<2)throw new Error("CubicSpline: need to set two derivatives at start and end points when set clamped boundary condition")}interpolate(){const{step:t,dataPoints:e}=this,{boundary:o,derivatives:n}=this.config,s=e.length/2,a=[],i=[],u=[],r=[],d=[],p=[],f=[],g=[],v=[],w=[],y=[],P=[],C=[];for(let l=0;l<s;l+=1)a[l]=e[2*(l+1)]-e[2*l];for(let l=1;l<s;l+=1){i[l]=a[l-1]/(a[l-1]+a[l]),u[l]=a[l]/(a[l-1]+a[l]);const x=(e[2*(l+1)+1]-e[2*l+1])/a[l],c=(e[2*l+1]-e[2*(l-1)+1])/a[l-1];r[l]=6/(a[l-1]+a[l])*(x-c)}switch(o){case m.Natural:r[0]=0,r[s-1]=0,u[0]=0,i[s-1]=0;break;case m.Clamped:{const[l,x]=n;r[0]=6*((e[3]-e[1])/a[0]-l)/a[0],r[s-1]=6*(x-(e[2*(s-1)+1]-e[2*(s-2)+1])/a[s-2])/a[s-2],u[0]=1,i[s-1]=1;break}case m.NotAKnot:r[0]=0,r[s-1]=0,u[0]=-2,i[s-1]=-2}d[0]=2,f[0]=u[0]/d[0];for(let l=1;l<s;l+=1)p[l]=i[l],d[l]=2-p[l]*f[l-1],f[l]=u[l]/d[l];v[0]=r[0]/d[0];for(let l=1;l<s;l+=1)v[l]=(r[l]-p[l]*v[l-1])/d[l];g[s-1]=v[s-1];for(let l=s-2;l>=0;l-=1)g[l]=v[l]-f[l]*g[l+1];for(let l=0;l<s;l+=1){const x=e[2*(l+1)+1]-e[2*l+1];w[l]=e[2*l+1],y[l]=x/a[l]-a[l]*(g[l]/3+g[l+1]/6),P[l]=g[l]/2,C[l]=(g[l+1]-g[l])/(6*a[l])}const S=[];for(let l=0;l<s;l+=1){const x=e[2*l],c=e[2*(l+1)];for(let b=x;b<=c;b+=t){const E=w[l]+y[l]*(b-x)+P[l]*(b-x)**2+C[l]*(b-x)**3;S.push(b,E)}}return S}}const tt=(h,t)=>(h[0]-t[0])**2+(h[1]-t[1])**2,et=h=>h[0]**2+h[1]**2,L=(h,t)=>{const e=[0,0,0,0],o=h[0],n=h[1],s=h[2],a=h[3];return e[0]=t[0]*o+t[4]*n+t[8]*s+t[12]*a,e[1]=t[1]*o+t[5]*n+t[9]*s+t[13]*a,e[2]=t[2]*o+t[6]*n+t[10]*s+t[14]*a,e[3]=t[3]*o+t[7]*n+t[11]*s+t[15]*a,e},W=(h,t)=>t===0?0:h/t;class k{constructor(t,e){this.val=[t!=null?t:0,e!=null?e:0]}get value(){return this.val}get x(){return this.val[0]}get y(){return this.val[1]}set(t,e){this.val[0]=t,this.val[1]=e}add(t){return this.val[0]+=t.x,this.val[1]+=t.y,this}subtract(t){return this.val[0]-=t.x,this.val[1]-=t.y,this}addScalar(t){return this.val[0]+=t,this.val[1]+=t,this}scale(t){return this.val[0]*=t,this.val[1]*=t,this}sqrLen(){return et(this.val)}sqrDist(t){return tt(t.value,this.val)}clone(){return new k(this.val[0],this.val[1])}}const N=h=>t=>new k(h[2*t],h[2*t+1]);class st extends j{constructor(t,e,o){super(t,e?Object.assign(A,e):A,o)}validate(){const{boundary:t,derivatives:e}=this.config;if(t===m.Clamped&&e.length<2)throw new Error("CubicParameterSpline: need to set two derivatives at start and end points when set clamped boundary condition")}interpolate(){const{step:t,dataPoints:e}=this,{boundary:o,derivatives:n}=this.config,s=N(e),a=e.length/2,i=[],u=[],r=[],d=[],p=[],f=[],g=[],v=[],w=[],y=[],P=[],C=[],S=[],l=[];for(let c=0;c<a-1;c+=1)l[c]=s(c+1).subtract(s(c)),i[c]=Math.sqrt(l[c].sqrLen());for(let c=1;c<a-1;c+=1){u[c]=i[c-1]/(i[c-1]+i[c]),r[c]=i[c]/(i[c-1]+i[c]);const b=new k,E=s(c+1),B=s(c),K=s(c-1);b.add(E).subtract(B).scale(1/i[c]),B.subtract(K).scale(1/i[c-1]),b.subtract(B),d[c]=b.scale(6/(i[c-1]+i[c]))}switch(o){case m.Natural:d[0]=new k(0,0),d[a-1]=new k(0,0),r[0]=0,u[a-1]=0;break;case m.Clamped:{const[c,b]=n,E=s(1),B=s(0),K=s(a-1),D=s(a-2);d[0]=E.subtract(B).scale(1/i[0]).addScalar(-c).scale(6/i[0]),d[a-1]=K.subtract(D).scale(1/i[a-2]).scale(-1).addScalar(b).scale(6/i[a-2]),r[0]=1,u[a-1]=1;break}case m.NotAKnot:d[0]=new k(0,0),d[a-1]=new k(0,0),r[0]=-2,u[a-1]=-2}p[0]=2,g[0]=r[0]/p[0];for(let c=1;c<a;c+=1)f[c]=u[c],p[c]=2-f[c]*g[c-1],g[c]=r[c]/p[c];w[0]=d[0].clone().scale(1/p[0]);for(let c=1;c<a;c+=1)w[c]=w[c-1].clone().scale(-f[c]).add(d[c]).scale(1/p[c]);v[a-1]=w[a-1].clone();for(let c=a-2;c>=0;c-=1)v[c]=v[c+1].clone().scale(-g[c]).add(w[c]);for(let c=0;c<a-1;c+=1){y[c]=s(c);const b=s(c+1).subtract(s(c)).scale(1/i[c]),E=v[c].clone().scale(1/3).add(v[c+1].clone().scale(1/6));P[c]=b.clone().subtract(E.scale(i[c])),C[c]=v[c].clone().scale(.5),S[c]=v[c+1].clone().subtract(v[c]).scale(1/(6*i[c]))}const x=[];for(let c=0;c<a;c+=1)for(let b=0;b<=i[c];b+=t){const E=y[c].clone(),B=P[c].clone().scale(b),K=C[c].clone().scale(b**2),D=S[c].clone().scale(b**3),R=E.add(B).add(K).add(D);x.push(R.x,R.y)}return x}}class nt extends j{constructor(t,e,o){const n=(s=>({derivatives:new Array(s).fill(0)}))(t.length);super(t,e?Object.assign(n,e):n,o)}validate(){if(this.dataPoints.length!==this.config.derivatives.length)throw new Error("HermiteSpline: need derivative at each data point")}interpolate(){const{dataPoints:t,config:{derivatives:e},step:o}=this,n=N(t),s=N(e),a=t.length/2,i=[];for(let u=0;u<a-1;u+=1)for(let r=0;r<=1;r+=o){const d=2*r**3-3*r**2+1,p=-2*r**3+3*r**2,f=r**3-2*r**2+r,g=r**3-r**2,v=n(u).scale(d).add(n(u+1).scale(p)).add(s(u).scale(f)).add(s(u+1).scale(g));i.push(v.x,v.y)}return i}}class ot extends j{constructor(t,e,o){if(t.length/2<4)throw new Error("CardinalSpline: need at least 4 data points");const n=(s=[t[0],t[1]],a=[t[t.length-2],t[t.length-1]],{vs:[s[0]+.01,s[1]+.01],ve:[a[0]+.01,a[1]+.01],tension:.1});var s,a;super(t,e?Object.assign(n,e):n,o)}validate(){if(!this.config.vs||!this.config.ve)throw new Error("CardinalSpline: need start and end virtual points")}interpolate(){const{dataPoints:t,config:{tension:e,vs:o,ve:n},step:s}=this,a=[...o,...t,...n],i=N(a),u=a.length/2;if(u<4)throw new Error("cardinal spline: needs at least 4 points");const r=(1-e)/2,d=[-r,2*r,-r,0,2-r,r-3,0,1,r-2,3-2*r,r,0,r,-r,0,0],p=[];for(let f=0;f<u-3;f+=1){let g=[i(f).x,i(f+1).x,i(f+2).x,i(f+3).x],v=[i(f).y,i(f+1).y,i(f+2).y,i(f+3).y];g=L(g,d),v=L(v,d);for(let w=0;w<1;w+=s){const y=new k(g[0],v[0]).scale(w**3),P=new k(g[1],v[1]).scale(w**2),C=new k(g[2],v[2]).scale(w**1),S=new k(g[3],v[3]),l=y.add(P).add(C).add(S);p.push(l.x,l.y)}}return p}}const at=(h,t,e,o)=>{const n=1-h,s=h**2,a=n**2,i=t.clone().scale(a);return i.add(e.clone().scale(2*n*h)),i.add(o.clone().scale(s)),i},rt=(h,t,e,o,n)=>{const s=1-h,a=h**2,i=s**2,u=s**3,r=h**3,d=t.clone().scale(u);return d.add(e.clone().scale(3*i*h)),d.add(o.clone().scale(3*s*a)),d.add(n.clone().scale(r)),d},U=(h,t=.01)=>{const e=s=>new k(h[2*s],h[2*s+1]),o=h.length/2,n=[];if(o===4){const s=e(0),a=e(1),i=e(2),u=e(3);for(let r=0;r<=1;r+=t){const d=rt(r,s,a,i,u);n.push(d.x,d.y)}}else if(o===3){const s=e(0),a=e(1),i=e(2);for(let u=0;u<=1;u+=t){const r=at(u,s,a,i);n.push(r.x,r.y)}}return n},z={tension:.5,closed:!1},I=(h,t,e,o=.5)=>{const n=e.clone().subtract(h),s=h.clone().sqrDist(t),a=t.clone().sqrDist(e),i=s+a,u=n.clone().scale(o*s/i),r=t.clone().subtract(u),d=n.clone().scale(o*a/i);return[r,t.clone().add(d)]};class lt extends j{constructor(t,e,o){super(t,e?Object.assign(z,e):z,o)}validate(){if(this.dataPoints.length/2<3)throw new Error("BezierSpline: need at least 3 points")}interpolate(){const{step:t,dataPoints:e}=this,{tension:o,closed:n}=this.config,s=[],a=e.length/2;for(let d=0;d<a;d+=1)s.push(new k(e[2*d],e[2*d+1]));const i=((d,p=.5,f=!1)=>{const g=f,v=[],w=d.length;for(let y=0;y<w-2;y+=1){const[P,C]=I(d[y],d[y+1],d[y+2],p);v.push(P,C)}if(g){const[y,P]=I(d[w-2],d[w-1],d[0],p);v.push(y,P);const[C,S]=I(d[w-1],d[0],d[1],p);v.push(C,S)}return v})(s,o,n),u=[],r=i.length;if(n)for(let d=1;d<=a;d+=1){const p=U([...s[d-1].value,...i[2*(d-1)-1<0?r-1:2*(d-1)-1].value,...i[2*(d-1)].value,...s[d%a].value],t);u.push(...p)}else{const d=U([...s[0].value,...i[0].value,...s[1].value],t);u.push(...d);for(let f=2;f<a-1;f+=1){const g=U([...s[f-1].value,...i[2*(f-1)-1].value,...i[2*(f-1)].value,...s[f].value],t);u.push(...g)}const p=U([...s[a-2].value,...i[2*(a-2)-1].value,...s[a-1].value],t);u.push(...p)}return u}}var H,q;(q=H||(H={}))[q.Uniform=0]="Uniform",q[q.QuasiUniform=1]="QuasiUniform",q[q.PiceceWise=2]="PiceceWise",q[q.NonUniform=3]="NonUniform";const it=h=>{const{points:t,k:e}=h,o=t.length/2,n=[];for(let s=0;s<=o+e;s+=1)n[s]=s/(o+e);return n},$=h=>{const{points:t,k:e}=h,o=t.length/2,n=[];for(let s=0;s<=o+e;s+=1)if(s<=e)n[s]=0;else if(s>=o)n[s]=1;else{const a=s-e;n[s]=a/(o-e)}return n},ct=h=>{const{points:t,k:e}=h,o=t.length/2;if((o-1)%e!=0)throw new Error("(n-1)/k is not an integer!");const n=[];for(let s=0;s<=o+e;s+=1)n[s]=s<=e?0:s>=o?1:.5;return n},F=h=>{const{points:t,k:e}=h,o=t.length/2,n=[],s=N(t);for(let a=0;a<=o+e;a+=1)if(a<=e)n[a]=0;else if(a>=o)n[a]=1;else{let i=0;for(let u=e+1;u<=a;u+=1){let r=0;for(let p=u-e;p<=u-1;p+=1)r+=Math.sqrt(s(p).sqrDist(s(p-1)));let d=0;for(let p=e+1;p<=o;p+=1)for(let f=p-e;f<=p-1;f+=1)d+=Math.sqrt(s(f).sqrDist(s(f-1)));i+=r/d}n[a]=i}return n},G=(h,t=1)=>{switch(t){case 0:return it(h);case 1:return $(h);case 2:return ct(h);case 3:return F(h);default:throw new Error(`BSpline: Not support knot type: ${t} !`)}},dt=h=>({k:3,knots:G({points:h,k:3})}),ht=h=>({k:3,knots:G({points:h,k:3}),w:new Array(h.length/2).fill(1)}),_=(h,t,e,o)=>{if(o===0)return t>=h[e]&&t<h[e+1]?1:0;if(o>0){const n=W(t-h[e],h[e+o]-h[e]),s=W(h[e+o+1]-t,h[e+o+1]-h[e+1]);return n*_(h,t,e,o-1)+s*_(h,t,e+1,o-1)}return 0};class ut extends j{constructor(t,e,o){const n=dt(t);super(t,e?Object.assign(n,e):n,o)}validate(){const{knots:t,k:e}=this.config,{dataPoints:o}=this;if(t.length<o.length/2+e+1)throw new Error("BSpline: need to set enough knots")}interpolate(){const{step:t,dataPoints:e}=this,{k:o,knots:n}=this.config,s=N(e),a=e.length/2,i=[],u=new k;for(let r=0;r<=1;r+=t){u.set(0,0);for(let d=0;d<a;d+=1){const p=_(n,r,d,o);u.add(s(d).scale(p))}i.push(u.x,u.y)}return i}insertKnot(t){if(t<=0||t>=1)throw new Error("knot value should in (0,1)");const{dataPoints:e,config:{knots:o,k:n}}=this,s=e.length/2,a=N(e),i=o.findIndex(r=>t<=r);o.splice(i,0,t);const u=[];for(let r=0;r<=i-n;r+=1)u.push(e[2*r],e[2*r+1]);for(let r=i-n+1;r<=i;r+=1){const d=t-o[r],p=o[r+n+1]-o[r];let f=0;p!==0&&(f=d/p);const g=a(r).scale(f).add(a(r-1).scale(1-f));u.push(g.x,g.y)}for(let r=i;r<s;r+=1){const d=a(r);u.push(d.x,d.y)}this.dataPoints=u}}class pt extends j{constructor(t,e,o){const n=ht(t);super(t,e?Object.assign(n,e):n,o)}validate(){const{knots:t,k:e}=this.config,{dataPoints:o}=this;if(t.length<o.length/2+e+1)throw new Error("NURBS: need to set enough knots")}interpolate(){const{step:t,dataPoints:e}=this,{k:o,w:n,knots:s}=this.config,a=N(e),i=e.length/2,u=new k,r=[];for(let d=0;d<=1;d+=t){u.set(0,0);let p=0;for(let f=0;f<i;f+=1){const g=_(s,d,f,o);u.add(a(f).scale(g*n[f])),p+=g*n[f]}u.scale(1/p),r.push(u.x,u.y)}return r}insertKnot(t){if(t<=0||t>=1)throw new Error("knot value should in (0,1)");const{dataPoints:e,config:{knots:o,k:n,w:s}}=this,a=e.length/2,i=N(e),u=o.findIndex(p=>t<=p);o.splice(u,0,t);const r=[],d=[];for(let p=0;p<=u-n;p+=1)r.push(e[2*p],e[2*p+1]),d.push(s[p]);for(let p=u-n+1;p<=u;p+=1){const f=t-o[p],g=o[p+n+1]-o[p];let v=0;g!==0&&(v=f/g);const w=i(p).scale(v).add(i(p-1).scale(1-v));r.push(w.x,w.y),d.push(v*s[p]+(1-v)*s[p-1])}for(let p=u;p<a;p+=1){const f=i(p);r.push(f.x,f.y),d.push(s[p])}this.dataPoints=r,this.setConfig({w:d})}}const Q={},ft=(h,t,e,o,n)=>{const s=h**2,a=h**3,i=e.clone().scale(2),u=o.clone().subtract(t),r=t.clone().scale(2).add(e.clone().scale(-5)).add(o.clone().scale(4)).add(n.clone().scale(-1)),d=t.clone().scale(-1).add(e.clone().scale(3)).add(o.clone().scale(-3)).add(n.clone().scale(1)),p=new k;return p.add(i).add(u.scale(h)).add(r.scale(s)).add(d.scale(a)).scale(.5),p};class gt extends j{constructor(t,e,o){super(t,e?Object.assign(Q,e):Q,o)}validate(){const{dataPoints:t}=this;if(t.length/2<4)throw new Error("CatmullRomSpline: need at least 4 points")}setPoints(t,e,o,n,s){const{step:a}=this;let i;for(let u=0;u<=1;u+=a)i=ft(u,e,o,n,s),t.push(i.x,i.y)}interpolate(){const{dataPoints:t}=this,e=t.length/2,o=[],n=s=>new k(t[2*s],t[2*s+1]);for(let s=0;s<e-1;s+=1)s===0?this.setPoints(o,n(0),n(0),n(1),n(2)):s===e-2?this.setPoints(o,n(s-1),n(s),n(s+1),n(s+1)):this.setPoints(o,n(s-1),n(s),n(s+1),n(s+2));return o}}const wt=T({props:{type:{type:String,required:!1}},setup(h){const t=h,{type:e}=t;let o=[50,250,200,150,100,50,250,70,400,50,450,250],n;switch(e){case"CubicSpline":{o=[50,250,100,50,200,150,250,70,380,100,450,250],n=new Z(o),n.setConfig({boundary:m.Clamped});break}case"CubicParameterSpline":{n=new st(o),n.setConfig({boundary:m.NotAKnot});break}case"CatmullRomSpline":{n=new gt(o),n.setConfig({tension:.7,closed:!0}),n.setStep(.001);break}case"HermiteSpline":{const i=[100,50,0,-100,200,10,0,100,100,20,0,-100];n=new nt(o),n.setConfig({derivatives:i});break}case"CardinalSpline":{n=new ot(o),n.setConfig({tension:.2});break}case"BezierSpline":{n=new lt(o),n.setConfig({tension:.7,closed:!0}),n.setStep(.001);break}case"BSpline":{n=new ut(o),n.setStep(.001),n.setConfig({k:4,knots:$({points:o,k:4})});break}case"NURBS":{n=new pt(o),n.setStep(.001),n.setConfig({k:4,knots:F({points:o,k:4})}),n.insertKnot(.35);break}}const s=n==null?void 0:n.getInterpolation(),a=s?[s]:[];return(i,u)=>{const r=V("canvas-wrapper");return X(),J("div",null,[Y(r,{points:M(o),lines:M(a)},null,8,["points","lines"])])}}});export{wt as default};
